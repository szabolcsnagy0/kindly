name: Claude Review

on:
  issue_comment:
    types: [created]

run-name: ${{ github.workflow }}--${{ github.event.issue.number }}

env:
  GITHUB_PR_NUMBER: ${{ github.event.issue.number }}

concurrency:
  group: claude-review-${{ github.event.issue.number }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  claude-review:
    # Trigger only on PR comments starting with '/claude-review'
    if: ${{ github.event.issue.pull_request && startsWith(github.event.comment.body, '/claude-review') }}
    runs-on: ubuntu-latest

    steps:
      - name: React to Trigger Comment
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: 'eyes'
            })

      - name: Checkout PR Code
        uses: actions/checkout@v4
        with:
          # Checkout the head of the PR branch
          ref: refs/pull/${{ env.GITHUB_PR_NUMBER }}/head
          # Fetch full history (depth: 0) so the agent can compare against main
          fetch-depth: 0

      - name: Post Start Comment
        id: initial-comment
        uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043 # 4.0.0
        with:
          issue-number: ${{ env.GITHUB_PR_NUMBER }}
          body: |
            Review started... I am analyzing your changes. üïµÔ∏è‚Äç‚ôÇÔ∏è

            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

      - name: Get PR Base Branch
        id: get-base
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            core.setOutput('base_branch', pr.data.base.ref);
            return pr.data.base.ref;

      - name: Fetch Base Branch
        run: git fetch origin ${{ steps.get-base.outputs.base_branch }}

      - name: Validate PR Has Changes
        run: |
          BASE_BRANCH="origin/${{ steps.get-base.outputs.base_branch }}"
          CHANGES=$(git --no-pager diff --name-only ${BASE_BRANCH}...HEAD | wc -l)
          if [ "$CHANGES" -eq 0 ]; then
            echo "No changes detected in this PR"
            exit 1
          fi
          echo "Found $CHANGES changed files against base branch: ${{ steps.get-base.outputs.base_branch }}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Create Audit Instructions
        env:
          BASE_BRANCH: ${{ steps.get-base.outputs.base_branch }}
        run: |
          cat << EOF > audit_instructions.md
          # Role: Senior Engineering Architect & Code Auditor

          **Objective:** Perform an exhaustive, professional code review of this Pull Request against the \`${BASE_BRANCH}\` branch.

          **Prime Directive:** Be thorough but precise. Flag real issues with clear justification. If code is production-ready, say so clearly.

          ## Phase 1: Comprehensive Context Gathering

          **CRITICAL:** All git commands MUST use \`--no-pager\`. Never trigger interactive shells.

          **CRITICAL:** This PR may contain MULTIPLE commits. You are reviewing the FINAL STATE of the code after ALL commits have been applied. Do NOT report issues that were introduced in early commits but fixed in later commits within the same PR.

          1. **Understand PR Structure:**
             ```bash
             git --no-pager log origin/${BASE_BRANCH}..HEAD --oneline
             ```
             - See how many commits are in this PR
             - Understand if there were progressive fixes

          2. **Get Complete Diff (for context only):**
             ```bash
             git --no-pager diff origin/${BASE_BRANCH}...HEAD
             ```
             - This shows the NET changes from ${BASE_BRANCH} to HEAD
             - Use this to understand WHAT areas of code changed
             - **DO NOT** report issues based solely on this diff

          3. **Identify All Changed Files:**
             ```bash
             git --no-pager diff --name-status origin/${BASE_BRANCH}...HEAD
             ```

          4. **MANDATORY: Read and Verify FINAL State:**
             - **YOU MUST** use the Read tool to get the COMPLETE final contents of EVERY changed file
             - **YOU MUST** verify every potential issue against the ACTUAL current code
             - The diff may show problematic code that was later fixed
             - **ONLY** report issues that exist in the final file state after reading it
             - **DO NOT** report an issue unless you've confirmed it exists by reading the actual file

          5. **Read Related Context:**
             - For each new file, understand its purpose in the broader architecture
             - Identify corresponding test files and read them fully
             - Look for related files that might be affected (imports, dependencies)

          6. **Understand the Change:**
             - What problem is being solved?
             - What is the scope of impact?
             - Are there related changes that should have been included?

          ## Phase 2: Multi-Dimensional Analysis

          Evaluate the changes across ALL dimensions below. Think critically about each.

          **Security (BLOCKING)**
          - Secrets & Credentials: Any hardcoded API keys, tokens, passwords, or sensitive data?
          - Injection Vulnerabilities: SQL injection, command injection, XSS, path traversal?
          - Input Validation: Are all external inputs (API payloads, user input, file uploads) validated?
          - Authentication & Authorization: Are security boundaries properly enforced?
          - Dependency Security: Any new dependencies with known vulnerabilities?

          **Architecture & Scaling**
          - Scalability: Will this work at 10x, 100x current load?
          - Database Performance: Are there N+1 queries, missing indexes, or table scans?
          - Memory & Resource Usage: Any memory leaks, unbounded collections, or resource exhaustion risks?
          - Architectural Consistency: Does this fit the existing system design patterns?
          - Service Boundaries: Are responsibilities properly separated?

          **Correctness & Robustness**
          - Error Handling: Are all error paths handled? Any swallowed errors?
          - Edge Cases: Null, undefined, empty arrays, boundary conditions, race conditions?
          - Async Safety: All Promises awaited? Proper async/await usage?
          - Data Integrity: Can this cause data corruption or inconsistency?
          - Concurrency: Thread-safe? Handles concurrent requests properly?

          **Consistency & Maintainability**
          - Code Style: Consistent with the existing codebase patterns?
          - Naming: Clear, descriptive, following project conventions?
          - Complexity: Is the solution as simple as it can be, or over-engineered?
          - Duplication: Is there existing code that does something similar?
          - Magic Numbers/Strings: Are constants properly named and documented?
          - Technical Debt: Does this add debt, or reduce it?

          **Failure Modes & Graceful Degradation**
          - Failure Impact: What happens when this code fails? Does it cascade?
          - Graceful Degradation: Can the system continue operating in a degraded state?
          - Rollback Safety: Can this change be safely rolled back?
          - Monitoring & Observability: Can failures be detected and diagnosed?
          - Retry Logic: Appropriate backoff and retry strategies?

          **Trap-Door Decisions**
          - Irreversible Choices: Are there decisions that will be hard to change later?
          - API Contracts: Are new APIs well-designed? Versioned if public?
          - Database Migrations: Are schema changes backwards compatible?
          - Breaking Changes: Any breaking changes to existing contracts?

          **Testing & Coverage**
          - Test Coverage: Are all new code paths tested?
          - Negative Tests: Are error paths and edge cases tested?
          - Integration Tests: Are interactions with other systems tested?
          - Test Quality: Are assertions specific and meaningful (not .any())?
          - Flakiness Risk: Are tests deterministic and reliable?

          **Complexity & Code Quality**
          - Cyclomatic Complexity: Is the code easy to understand?
          - Nesting Depth: Too many nested conditionals or callbacks?
          - Function Length: Are functions focused and reasonably sized?
          - Debug Artifacts: Any console.log, debugger, or commented code?
          - Documentation: Are complex algorithms or business logic explained?

          ## Phase 3: Output Format (STRICT)

          **CRITICAL:** Your response must start IMMEDIATELY with either "## ‚úÖ APPROVED" or "## ‚ö†Ô∏è ISSUES FOUND"

          DO NOT include:
          - Any conversational text or preamble
          - Phrases like "Perfect!", "Let me analyze...", "Based on my review..."
          - Any text before the ## heading
          - Any explanatory text after the formatted output
          - **ANY section headers or groupings** like "Security Issues:", "Testing Issues:", "Code Quality Issues:"
          - Any markdown headings other than the main "## ‚úÖ APPROVED" or "## ‚ö†Ô∏è ISSUES FOUND"
          - Any blank lines between issues in the numbered list

          ### If No Significant Issues

          ```markdown
          ## ‚úÖ APPROVED

          **Summary:** [2-3 sentences describing what changed and confirming it's production-ready]

          No significant issues found. Changes reviewed for security, architecture, correctness, testing, and code quality.
          ```

          ### If Issues Found

          **CRITICAL FORMAT:** The output must be EXACTLY as shown below - a flat numbered list with NO section headers.

          ```markdown
          ## ‚ö†Ô∏è ISSUES FOUND

          1. **[Security] file.ts:123** - SQL injection in database query - Use parameterized queries
          2. **[Correctness] handler.ts:45** - Missing await on async function - Add await keyword
          3. **[Testing] service.test.ts:89** - Weak assertion using .any() - Use specific expected values
          4. **[Performance] api.ts:67** - N+1 query in loop - Use batch loading
          5. **[Quality] utils.ts:12** - Console.log in production code - Remove or use logger
          ```

          **Format Rules (MANDATORY):**
          - Your ENTIRE response must be ONLY the formatted output above
          - Start immediately with "## ‚ö†Ô∏è ISSUES FOUND" on line 1
          - Line 2 must be blank
          - Line 3+ is the numbered list starting with "1. "
          - **ABSOLUTELY NO section headers** like "Security Issues", "Testing Issues", etc.
          - **FLAT NUMBERED LIST ONLY** - issues should be numbered 1, 2, 3, 4, 5... continuously
          - One line per issue: \`**[Category] file:line** - problem description - suggested fix\`
          - Categories: Security, Performance, Correctness, Architecture, Testing, Quality
          - Keep each issue to one line, be concise
          - No sub-bullets, no Impact sections, no detailed explanations
          - No executive summary, no overall assessment sections
          - No grouping by category
          - No conversational text before or after
          - Just the heading, blank line, and flat numbered list
          EOF

      - name: Run Claude Review
        id: review
        continue-on-error: true
        timeout-minutes: 10
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CI: true
        run: |
          claude --print "$(cat audit_instructions.md)" > review_report.md

      - name: Debug Review Output
        if: always()
        run: |
          echo "=== Review report file info ==="
          ls -lah review_report.md || echo "File not found"
          echo "=== Review report contents ==="
          cat review_report.md || echo "Cannot read file"
          echo "=== Review report hex dump (first 100 bytes) ==="
          xxd -l 100 review_report.md || echo "Cannot dump file"

      - name: Post Success Comment
        if: ${{ steps.review.outcome == 'success' }}
        uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043 # 4.0.0
        with:
          comment-id: ${{ steps.initial-comment.outputs.comment-id }}
          issue-number: ${{ env.GITHUB_PR_NUMBER }}
          body-path: review_report.md
          edit-mode: replace

      - name: Post Failure Comment
        if: ${{ steps.review.outcome == 'failure' }}
        uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1eff043 # 4.0.0
        with:
          comment-id: ${{ steps.initial-comment.outputs.comment-id }}
          issue-number: ${{ env.GITHUB_PR_NUMBER }}
          body: |
            :x: Claude review failed to complete.

            [View workflow run for details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          edit-mode: replace
